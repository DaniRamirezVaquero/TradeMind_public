import { Injectable } from '@angular/core';
import { Message } from '../interfaces/message';
import {
  BehaviorSubject,
  Subject,
  Observable,
  firstValueFrom,
  timeout,
  catchError,
  of,
} from 'rxjs';
import { HttpClient, HttpErrorResponse } from '@angular/common/http';
import { environment } from '../../environments/environment';
import { ChatSession, HealthCheckResponse } from '../interfaces/chat-session';

@Injectable({
  providedIn: 'root',
})
export class ChatService {
  private messageSubject = new Subject<Message>();
  private toolResultSubject = new Subject<Message>();
  private loadingSubject = new BehaviorSubject<boolean>(false);
  private currentChatSubject = new BehaviorSubject<string | null>(null);
  private tokenLimitReachedSubject = new Subject<string>();
  private backendReadySubject = new BehaviorSubject<boolean>(false);
  private backendInitializingSubject = new BehaviorSubject<boolean>(true);
  private chatTitleUpdateSubject = new Subject<{
    chatId: string;
    title: string;
    isAutoGenerated: boolean;
  }>();

  private sessionId: string | null = null;
  private currentChatId: string | null = null;

  private messageCache: { [chatId: string]: Message[] } = {}; // Cache of messages by chat ID
  private tokenLimitedChatsCache: Set<string> = new Set(); // Cache para chats con límite

  tokenLimitReached$ = this.tokenLimitReachedSubject.asObservable();
  messages$ = this.messageSubject.asObservable();
  toolResults$ = this.toolResultSubject.asObservable();
  loading$ = this.loadingSubject.asObservable();
  currentChatId$ = this.currentChatSubject.asObservable();
  chatTitleUpdate$ = this.chatTitleUpdateSubject.asObservable();
  backendReady$ = this.backendReadySubject.asObservable();
  backendInitializing$ = this.backendInitializingSubject.asObservable();

  private apiUrl = environment.apiUrl;

  constructor(private http: HttpClient) {
    this.checkBackendStatus();
  }

  private async checkBackendStatus() {
    this.backendInitializingSubject.next(true);

    try {
      // Intentar hacer una petición simple al backend
      const response = await firstValueFrom(
        this.http.get<HealthCheckResponse>(`${this.apiUrl}/health-check`).pipe(
          timeout(5000),
          catchError((error: HttpErrorResponse) => {
            // Cualquier error HTTP debe propagarse como error, no convertirse a valor
            console.log('Backend no disponible:', error.message);
            throw error; // Importante: re-lanzar el error para que se capture en el catch externo
          })
        )
      );

      // Solo llegamos aquí si la respuesta es exitosa
      if (response && response['status'] === 'up') {
        console.log('Backend está listo');
        this.backendReadySubject.next(true);
        this.backendInitializingSubject.next(false);
      } else {
        // Respuesta inválida o incompleta
        console.error('Respuesta inesperada del servidor:', response);
        throw new Error('Respuesta inválida del servidor');
      }
    } catch (error) {
      console.error('Error verificando estado del backend:', error);
      this.backendReadySubject.next(false); // Asegurarse de que el estado es correcto
      this.backendInitializingSubject.next(true);

      // Iniciar polling para verificar hasta que esté disponible
      this.startBackendPolling();
    }
  }

  private startBackendPolling() {
    console.log('Iniciando polling del backend...');

    const pollingInterval = setInterval(async () => {
      try {
        const response = await firstValueFrom(
          this.http
            .get<HealthCheckResponse>(`${this.apiUrl}/health-check`)
            .pipe(
              timeout(5000),
              catchError((error: HttpErrorResponse) => {
                // Cualquier error HTTP debe propagarse
                throw error;
              })
            )
        );

        // Verificar explícitamente que recibimos la respuesta correcta
        if (response && response['status'] === 'up') {
          console.log('Backend ahora está disponible');
          this.backendReadySubject.next(true);
          this.backendInitializingSubject.next(false);
          clearInterval(pollingInterval);

          // Intentar la inicialización de la sesión después de que el backend está disponible
          try {
            await this.initializeSession();
          } catch (error) {
            console.error(
              'Error en la inicialización después de backend disponible:',
              error
            );
          }
        } else {
          console.log(
            'Respuesta inválida del servidor, continuando polling...'
          );
        }
      } catch (error) {
        console.log('Backend todavía no disponible, continuando polling...');
      }
    }, 5000); // Verificar cada 5 segundos
  }

  // Method to set the current chat
  setCurrentChat(chatId: string): void {
    this.currentChatId = chatId;
    this.currentChatSubject.next(chatId);

    // Verificar el estado de límite de tokens desde el backend
    this.refreshChatTokenLimitState(chatId);
  }

  // Añadir nuevo método para refrescar solo el estado de límite de tokens
  private async refreshChatTokenLimitState(chatId: string): Promise<void> {
    try {
      // Consulta ligera solo para obtener el estado actualizado
      const response = await firstValueFrom(
        this.http.get<{ tokenLimitReached: boolean }>(
          `${this.apiUrl}/chats/${chatId}/state`
        )
      );

      this.setChatTokenLimited(chatId, response.tokenLimitReached);

      // Si el estado ha cambiado y ahora está limitado, notificarlo
      if (
        response.tokenLimitReached &&
        !this.tokenLimitedChatsCache.has(chatId)
      ) {
        this.tokenLimitReachedSubject.next(chatId);
      }
    } catch (error) {
      console.error('Error refreshing chat token limit state:', error);
    }
  }

  // Get current chat ID
  getCurrentChatId(): string | null {
    return this.currentChatId;
  }

  // Añadir método para verificar si un chat ha alcanzado el límite
  // Actualizar el método para verificar si un chat ha alcanzado el límite
  isChatTokenLimited(chatId: string): boolean {
    // Primero verificar nuestra caché en memoria
    if (this.tokenLimitedChatsCache.has(chatId)) {
      return true;
    }
    // Luego verificar localStorage (y actualizar caché si es necesario)
    if (
      localStorage.getItem(`tradeMind_chat_tokenlimit_${chatId}`) === 'true'
    ) {
      this.tokenLimitedChatsCache.add(chatId);
      return true;
    }
    return false;
  }

  setChatTokenLimited(chatId: string, isLimited: boolean): void {
    if (isLimited) {
      this.tokenLimitedChatsCache.add(chatId);
      localStorage.setItem(`tradeMind_chat_tokenlimit_${chatId}`, 'true');
    } else {
      this.tokenLimitedChatsCache.delete(chatId);
      localStorage.removeItem(`tradeMind_chat_tokenlimit_${chatId}`);
    }
  }

  // Update the loadChat method to use cached messages when available
  async loadChat(chatId: string, forceRefresh = false): Promise<Message[]> {
    try {
      // If we need to force refresh, skip the cache
      if (forceRefresh) {
        return await this.fetchChatFromBackend(chatId);
      }

      // First check in-memory cache
      if (this.messageCache[chatId] && this.messageCache[chatId].length > 0) {
        console.log(
          `Using ${this.messageCache[chatId].length} messages from memory cache for chat ${chatId}`
        );
        return this.messageCache[chatId];
      }

      // Then try to load from localStorage
      try {
        const cachedMessages = localStorage.getItem(`tradeMind_chat_${chatId}`);
        if (cachedMessages) {
          const messages = JSON.parse(cachedMessages);
          if (messages && messages.length > 0) {
            console.log(
              `Loaded ${messages.length} messages from localStorage for chat ${chatId}`
            );
            // Store in memory cache
            this.messageCache[chatId] = messages;
            return messages;
          }
        }
      } catch (e) {
        console.error('Error loading from localStorage:', e);
      }

      // If not in cache or localStorage, fetch from backend
      return await this.fetchChatFromBackend(chatId);
    } catch (error) {
      console.error('Error loading chat:', error);
      return this.messageCache[chatId] || [];
    }
  }

  // Helper method to fetch from backend
  private async fetchChatFromBackend(chatId: string): Promise<Message[]> {
    console.log(`Fetching chat ${chatId} from backend`);
    const response = await firstValueFrom(
      this.http.get<{
        id: string;
        messages: Message[];
        title: string;
        tokenLimitReached?: boolean; // Añadir esta propiedad
      }>(`${this.apiUrl}/chats/${chatId}`)
    );

    console.log(
      `Got ${
        response.messages?.length || 0
      } messages from backend for chat ${chatId}`
    );

    // Normalize message types for consistency
    const normalizedMessages = this.normalizeMessageTypes(response.messages);

    // Update cache
    this.messageCache[chatId] = normalizedMessages;
    this.saveMessagesToStorage(chatId, normalizedMessages);

    // Set as current chat
    this.currentChatId = chatId;

    // Verificar si el chat está limitado por tokens y actualizar localStorage
    if (response.tokenLimitReached) {
      console.log(`Chat ${chatId} has reached token limit`);
      this.setChatTokenLimited(chatId, true);
    } else {
      this.setChatTokenLimited(chatId, false);
    }

    return normalizedMessages;
  }

  sendMessageToChat(chatId: string, message: Message) {
    if (!this.backendReadySubject.value) {
      console.error('No se puede enviar mensaje, backend no disponible');
      return;
    }

    if (!this.sessionId || !chatId) {
      console.error('No active session or chat ID');
      return;
    }

    console.log(`Sending message to chat ${chatId}:`, message);

    // Emit user message immediately
    this.messageSubject.next(message);
    this.loadingSubject.next(true);

    // Add message to local cache immediately
    if (!this.messageCache[chatId]) {
      this.messageCache[chatId] = [];
    }
    this.messageCache[chatId].push(message);
    this.saveMessagesToStorage(chatId, this.messageCache[chatId]);

    const payload = {
      content: message.content,
      type: 'Human',
    };

    this.http
      .post<{
        messages: Message[];
        chatId: string;
        title?: string;
        tokenLimitReached?: boolean;
      }>(`${this.apiUrl}/chats/${chatId}/message`, payload)
      .subscribe({
        next: (response) => {
          console.log(
            `Received ${response.messages.length} response messages:`,
            response.messages
          );

          // Normalize types for consistency
          const normalizedMessages = this.normalizeMessageTypes(
            response.messages
          );

          // Add new messages to cache
          if (!this.messageCache[chatId]) {
            this.messageCache[chatId] = [];
          }

          // Append the new messages to existing ones
          this.messageCache[chatId] = [
            ...this.messageCache[chatId],
            ...normalizedMessages,
          ];

          console.log(
            `Updated cache for chat ${chatId}, now has ${this.messageCache[chatId].length} messages`
          );

          this.saveMessagesToStorage(chatId, this.messageCache[chatId]);

          // Emit new messages
          let hasToolResults = normalizedMessages.some(
            (msg) => msg.type === 'tool_result'
          );
          normalizedMessages.forEach((msg) => {
            // Ignorar mensajes AI vacíos cuando hay tool_results en la misma respuesta
            if (msg.type === 'AI') {
              // Solo emitir mensajes AI si tienen contenido o si no hay tool_results
              if (msg.content.trim() || !hasToolResults) {
                this.messageSubject.next(msg);
              } else {
                console.log(
                  'Ignorando mensaje AI vacío que precede a tool_results'
                );
              }
            } else if (msg.type === 'tool_result') {
              this.toolResultSubject.next(msg);
            }
          });

          // Handle title update if present
          if (response.title) {
            // Store title in localStorage
            localStorage.setItem(
              `tradeMind_chat_title_${chatId}`,
              response.title
            );

            this.chatTitleUpdateSubject.next({
              chatId: chatId,
              title: response.title,
              isAutoGenerated: true, // This is auto-generated
            });
          }

          // Handle token limit reached
          if (response.tokenLimitReached) {
            // Usar nuestro nuevo método
            this.setChatTokenLimited(chatId, true);

            // Emitir la notificación de límite alcanzado
            this.tokenLimitReachedSubject.next(chatId);
          }

          // Notify preview update for the chat
          this.notifyChatPreviewUpdate(chatId, this.messageCache[chatId]);

          this.loadingSubject.next(false);
        },
        error: (error) => {
          console.error('Error sending message:', error);

          // Check if error is due to token limit
          if (
            error.status === 400 &&
            error.error?.detail?.includes('Token limit reached')
          ) {
            // Usar nuestro nuevo método
            this.setChatTokenLimited(chatId, true);

            // Emitir la notificación de límite alcanzado
            this.tokenLimitReachedSubject.next(chatId);

            // Add a system message about the limit
            const tokenLimitMsg: Message = {
              type: 'AI',
              content:
                '⚠️ Esta conversación ha alcanzado el límite de tokens. No se pueden procesar más mensajes en este chat. Por favor, crea una nueva conversación para continuar.',
              id: 'system_token_limit',
            };

            this.messageSubject.next(tokenLimitMsg);

            if (!this.messageCache[chatId]) {
              this.messageCache[chatId] = [];
            }
            this.messageCache[chatId].push(tokenLimitMsg);
            this.saveMessagesToStorage(chatId, this.messageCache[chatId]);
          }

          this.loadingSubject.next(false);
        },
      });
  }

  async getChatTitle(chatId: string): Promise<string> {
    // First check localStorage
    const cachedTitle = localStorage.getItem(`tradeMind_chat_title_${chatId}`);
    if (cachedTitle) {
      return cachedTitle;
    }

    // If not in localStorage, fetch from backend
    try {
      const response = await firstValueFrom(
        this.http.get<ChatSession>(`${this.apiUrl}/chats/${chatId}`)
      );

      // Store for future use
      localStorage.setItem(`tradeMind_chat_title_${chatId}`, response.title);

      return response.title;
    } catch (error) {
      console.error(`Error fetching title for chat ${chatId}:`, error);
      return 'Chat'; // Default fallback
    }
  }

  // Create new chat in the current session
  async createNewChat(
    title: string = 'Nueva conversación'
  ): Promise<ChatSession> {
    if (!this.sessionId) {
      throw new Error('No active session');
    }

    try {
      const response = await firstValueFrom(
        this.http.post<ChatSession>(`${this.apiUrl}/chats`, {
          sessionId: this.sessionId,
          title,
        })
      );

      this.currentChatId = response.id;

      // Initialize empty cache for the new chat
      this.messageCache[response.id] = [];

      return response;
    } catch (error) {
      console.error('Error creating new chat:', error);
      throw error;
    }
  }

  // Update chat title
  async updateChatTitle(
    chatId: string,
    newTitle: string
  ): Promise<ChatSession> {
    try {
      const response = await firstValueFrom(
        this.http.put<ChatSession>(`${this.apiUrl}/chats/${chatId}`, {
          title: newTitle,
        })
      );

      // Store title in localStorage for quick access
      localStorage.setItem(`tradeMind_chat_title_${chatId}`, response.title);

      this.chatTitleUpdateSubject.next({
        chatId: response.id,
        title: response.title,
        isAutoGenerated: false, // This is manually updated
      });

      return response;
    } catch (error) {
      console.error('Error updating chat title:', error);
      throw error;
    }
  }

  // Delete chat
  async deleteChat(chatId: string): Promise<boolean> {
    try {
      await firstValueFrom(
        this.http.delete<{ success: boolean }>(`${this.apiUrl}/chats/${chatId}`)
      );

      // Remove from cache
      if (this.messageCache[chatId]) {
        delete this.messageCache[chatId];
        localStorage.removeItem(`tradeMind_chat_${chatId}`);
      }

      return true;
    } catch (error) {
      console.error('Error deleting chat:', error);
      return false;
    }
  }

  // Get messages for a specific chat
  getMessagesForChat(chatId: string): Message[] {
    return this.messageCache[chatId] || [];
  }

  // Updated notification method
  private notifyChatPreviewUpdate(chatId: string, messages: Message[]): void {
    if (!messages.length) return;

    // Find the last user or AI message
    let previewMessage: Message | undefined;
    for (let i = messages.length - 1; i >= 0; i--) {
      if (messages[i].type === 'Human' || messages[i].type === 'AI') {
        previewMessage = messages[i];
        break;
      }
    }

    if (previewMessage) {
      const event = new CustomEvent('chatPreviewUpdate', {
        detail: {
          chatId: chatId,
          previewText: previewMessage.content.substring(0, 100),
        },
      });
      window.dispatchEvent(event);
    }
  }

  // Método para cargar el caché de mensajes desde localStorage
  private loadMessageCacheFromStorage(): void {
    try {
      // Buscar todas las claves en localStorage que empiezan con 'tradeMind_chat_'
      for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        if (key && key.startsWith('tradeMind_chat_')) {
          const chatId = key.replace('tradeMind_chat_', '');
          const messages = JSON.parse(localStorage.getItem(key) || '[]');
          this.messageCache[chatId] = messages;
        }
      }
    } catch (error) {
      console.error('Error loading message cache from localStorage', error);
    }
  }

  // Método para guardar mensajes de una sesión en localStorage
  private saveMessagesToStorage(chatId: string, messages: Message[]): void {
    try {
      localStorage.setItem(
        `tradeMind_chat_${chatId}`,
        JSON.stringify(messages)
      );
    } catch (error) {
      console.error('Error saving messages to localStorage', error);
    }
  }

  // Normalizar tipos de mensajes
  private normalizeMessageTypes(messages: Message[]): Message[] {
    return messages.map((msg) => ({
      ...msg,
      type: msg.type === 'tool' ? 'tool_result' : msg.type,
    }));
  }

  async initializeSession(): Promise<{
    sessionId: string;
    chats: ChatSession[];
  }> {
    if (!this.backendReadySubject.value) {
      this.backendInitializingSubject.next(true);
      console.log(
        'Intentando inicializar sesión pero el backend no está listo'
      );
      throw new Error('Backend no disponible');
    }

    // Check if we have a stored session ID
    const savedSessionId = localStorage.getItem('tradeMind_sessionId');

    try {
      let response;

      if (savedSessionId) {
        // Get existing session's chats
        response = await firstValueFrom(
          this.http.get<{ sessionId: string; chats: ChatSession[] }>(
            `${this.apiUrl}/sessions/${savedSessionId}/chats`
          )
        );
      } else {
        // Create new session if we don't have one
        response = await firstValueFrom(
          this.http.post<{ sessionId: string; chats: ChatSession[] }>(
            `${this.apiUrl}/init-session`,
            {}
          )
        );
      }

      // Store session ID
      this.sessionId = response.sessionId;
      localStorage.setItem('tradeMind_sessionId', this.sessionId);

      // Process any returned chats and their initial messages
      if (response.chats && response.chats.length > 0) {
        // Actualizar la información de tokenLimitReached en localStorage
        response.chats.forEach((chat) => {
          this.setChatTokenLimited(chat.id, !!chat.tokenLimitReached);
        });

        // For each chat, we need to load its messages
        for (const chat of response.chats) {
          try {
            // Load the actual messages for this chat
            const chatResponse = await firstValueFrom(
              this.http.get<{ id: string; messages: Message[]; title: string }>(
                `${this.apiUrl}/chats/${chat.id}`
              )
            );

            if (chatResponse.messages && chatResponse.messages.length > 0) {
              const normalizedMessages = this.normalizeMessageTypes(
                chatResponse.messages
              );
              this.messageCache[chat.id] = normalizedMessages;
              this.saveMessagesToStorage(chat.id, normalizedMessages);
            } else {
              // Initialize with empty array if no messages
              this.messageCache[chat.id] = [];
            }
          } catch (err) {
            console.error(`Error loading messages for chat ${chat.id}:`, err);
            // Initialize with empty array if loading fails
            this.messageCache[chat.id] = [];
          }
        }

        // Set current chat to the first one
        this.setCurrentChat(response.chats[0].id);
      }

      // Run cleanup AFTER initializing all proper chats
      this.cleanupOldStorageFormat();
      this.cleanupOrphanedStorageEntries();

      return response;
    } catch (error) {
      console.error('Error initializing session:', error);

      // If there was an error and we were using a saved session ID,
      // clear it and try again with a fresh session
      if (savedSessionId) {
        localStorage.removeItem('tradeMind_sessionId');
        return this.initializeSession(); // Try again with no saved session
      }

      throw error; // If we can't create a session at all, propagate the error
    }
  }

  private cleanupOldStorageFormat(): void {
    try {
      // First, find the session ID (if it exists in localStorage)
      const sessionId = localStorage.getItem('tradeMind_sessionId');

      if (sessionId) {
        // Remove the old session-based cache if it exists
        localStorage.removeItem(`tradeMind_chat_${sessionId}`);
      }

      // Also check if there are any orphaned entries that don't match our chats
      for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        if (key && key.startsWith('tradeMind_chat_')) {
          const chatId = key.replace('tradeMind_chat_', '');

          // If this chat ID is not in our messageCache, remove it
          if (!this.messageCache[chatId]) {
            localStorage.removeItem(key);
          }
        }
      }
    } catch (error) {
      console.error('Error cleaning up old storage format', error);
    }
  }

  private cleanupOrphanedStorageEntries(): void {
    // Execute this after we've loaded active chats
    setTimeout(() => {
      try {
        // Get all localStorage keys that start with our prefix
        const chatKeys: string[] = [];
        for (let i = 0; i < localStorage.length; i++) {
          const key = localStorage.key(i);
          if (key && key.startsWith('tradeMind_chat_')) {
            chatKeys.push(key);
          }
        }

        // If we have active chats, remove any localStorage entries not in our active chats
        if (Object.keys(this.messageCache).length > 0) {
          chatKeys.forEach((key) => {
            const chatId = key.replace('tradeMind_chat_', '');
            if (!this.messageCache[chatId]) {
              console.log('Removing orphaned chat storage:', key);
              localStorage.removeItem(key);
            }
          });
        }
      } catch (error) {
        console.error('Error cleaning up orphaned storage entries', error);
      }
    }, 2000); // Give time for chats to load
  }
}
